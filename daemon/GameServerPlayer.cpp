#include <stdio.h>
#include "GameServerPlayer.h"
#include "PacketUtils.h"
#include "GameServer_Login.h"
#include "GameServer_MoveOutOfRoom.h"
#include "Character.h"
#include "PathUtils.h"
#include "StdStreamUtils.h"

#define LOGNAME "GameServerPlayer"

CGameServerPlayer::CGameServerPlayer(SOCKET clientSocket)
: m_clientSocket(clientSocket)
, m_disconnect(false)
, m_alreadyMovedOutOfRoom(false)
{
	PrepareInitialPackets();
}

CGameServerPlayer::~CGameServerPlayer()
{

}

bool CGameServerPlayer::IsConnected() const
{
	return !m_disconnect;
}

static PacketData GetMotd()
{
	std::vector<const char*> messages;
	messages.push_back("Welcome to the Seventh Umbral Server");
	messages.push_back("Compiled on: " __DATE__);
	messages.push_back("---------------");

	const static uint8 packetHeader[] =
	{
		0x01, 0x00, 0x00, 0x00, 0x58, 0x02, 0x06, 0x00, 0xF9, 0x18, 0x8B, 0xEE, 0x3B, 0x01, 0x00, 0x00
	};

	PacketData outgoingPacket;
	outgoingPacket.insert(std::end(outgoingPacket), std::begin(packetHeader), std::end(packetHeader));

	for(auto message : messages)
	{
		uint8 messagePacket[0x248] = 
		{
			0x48, 0x02, 0x03, 0x00, 0x41, 0x29, 0x9B, 0x02, 0x41, 0x29, 0x9B, 0x02, 0x00, 0xE0, 0xD2, 0xFE, 
			0x14, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0xE8, 0xE0, 0x50, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		};

		memcpy(messagePacket + 0x44, message, strlen(message) + 1);

		outgoingPacket.insert(std::end(outgoingPacket), std::begin(messagePacket), std::end(messagePacket));
	}

	uint32 packetSize = outgoingPacket.size();
	assert(packetSize < 0x10000);

	*reinterpret_cast<uint16*>(outgoingPacket.data() + 0x4) = static_cast<uint16>(packetSize);

	return outgoingPacket;
}

static PacketData GetCharacterInfo()
{
	PacketData outgoingPacket(std::begin(g_client0_login8), std::end(g_client0_login8));

	CCharacter character;
	auto personalDataPath = Framework::PathUtils::GetPersonalDataPath();
	auto characterPath = personalDataPath / "ffxivd_character.xml";
	if(boost::filesystem::exists(characterPath))
	{
		auto inputStream = Framework::CreateInputStdStream(characterPath.native());
		character.Load(inputStream);
	}

	const uint32 characterInfoBase = 0x368;

	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x20]) = CCharacter::GetModelFromTribe(character.tribe);
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x28]) = character.size;
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x30]) = character.GetColorInfo();
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x38]) = character.GetFaceInfo();
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x40]) = character.hairStyle << 10;
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x48]) = character.voice;
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x50]) = 0;						//weapon

	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x88]) = character.headGear;		//headGear
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x90]) = character.bodyGear;		//bodyGear
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0x98]) = character.legsGear;		//legsGear
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0xA0]) = character.handsGear;	//handsGear
	*reinterpret_cast<uint32*>(&outgoingPacket[characterInfoBase + 0xA8]) = character.feetGear;		//feetGear

	//Insert character name
	for(unsigned int i = 0; i < character.name.size(); i++)
	{
		outgoingPacket[characterInfoBase + 0x14C + i] = character.name[i];
	}
	outgoingPacket[characterInfoBase + 0x14C + character.name.size()] = 0;

	return outgoingPacket;
}

void CGameServerPlayer::QueuePacket(const PacketData& packet)
{
	m_packetQueue.push_back(packet);
}

void CGameServerPlayer::Update()
{
	//Write to socket
	{
		int totalSent = 0;
		while(!m_packetQueue.empty())
		{
			if(totalSent >= 0x1000)
			{
				Sleep(100);
				break;
			}
			const auto& nextPacket = m_packetQueue.front();
			int sent = send(m_clientSocket, reinterpret_cast<const char*>(nextPacket.data()), nextPacket.size(), 0);
			assert(sent == nextPacket.size());
			m_packetQueue.pop_front();
			totalSent += sent;
		}
	}

	//Read from socket
	{
		static const unsigned int maxPacketSize = 0x10000;
		uint8 incomingPacket[maxPacketSize];
		int read = recv(m_clientSocket, reinterpret_cast<char*>(incomingPacket), maxPacketSize, 0);
		if(read == 0)
		{
			//Client disconnected
			printf("%s: Client disconnected.\r\n", LOGNAME);
			m_disconnect = true;
			return;
		}
		if(read > 0)
		{
			m_incomingStream.Write(incomingPacket, read);
		}
	}

	if(CPacketUtils::HasPacket(m_incomingStream))
	{
		auto incomingPacket = CPacketUtils::ReadPacket(m_incomingStream);
		auto subPackets = CPacketUtils::SplitPacket(incomingPacket);
		bool killConnection = false;

		for(const auto& subPacket : subPackets)
		{
			uint16 commandId = CPacketUtils::GetSubPacketCommand(subPacket);
			switch(commandId)
			{
			case 0x0001:
				ProcessKeepAlive(subPacket);
				break;
			case 0x00CA:
				ProcessSetPlayerPosition(subPacket);
				break;
			case 0x012D:
				ProcessScriptCommand(subPacket);
				break;
			case 0x012E:
				ProcessScriptResult(subPacket);
				break;
			default:
				printf("%s: Unknown command 0x%0.4X received.\r\n", LOGNAME, commandId);
				break;
			}
		}
	}
}

void CGameServerPlayer::PrepareInitialPackets()
{
	QueuePacket(PacketData(std::begin(g_client0_login1), std::end(g_client0_login1)));
	QueuePacket(PacketData(std::begin(g_client0_login2), std::end(g_client0_login2)));
	QueuePacket(PacketData(std::begin(g_client0_login3), std::end(g_client0_login3)));
	QueuePacket(PacketData(std::begin(g_client0_login4), std::end(g_client0_login4)));
	QueuePacket(PacketData(GetMotd()));
	QueuePacket(PacketData(std::begin(g_client0_login7), std::end(g_client0_login7)));
	QueuePacket(PacketData(GetCharacterInfo()));
	QueuePacket(PacketData(std::begin(g_client0_login9), std::end(g_client0_login9)));
	QueuePacket(PacketData(std::begin(g_client0_login10), std::end(g_client0_login10)));
	QueuePacket(PacketData(std::begin(g_client0_login11), std::end(g_client0_login11)));
	QueuePacket(PacketData(std::begin(g_client0_login12), std::end(g_client0_login12)));
	QueuePacket(PacketData(std::begin(g_client0_login13), std::end(g_client0_login13)));
	QueuePacket(PacketData(std::begin(g_client0_login14), std::end(g_client0_login14)));
}

void CGameServerPlayer::ProcessKeepAlive(const PacketData& subPacket)
{
	//Some keep alive thing? (only time is updated here)
	uint32 clientTime = *reinterpret_cast<const uint32*>(&subPacket[0x18]);
	uint32 moreTime = *reinterpret_cast<const uint32*>(&subPacket[0x20]);

	uint8 keepAlivePacket[0x50] =
	{
		0x01, 0x00, 0x00, 0x00, 0x50, 0x00, 0x01, 0x00, 0xEF, 0xCB, 0xA4, 0xEE, 0x3B, 0x01, 0x00, 0x00,
		0x40, 0x00, 0x03, 0x00, 0x41, 0x29, 0x9b, 0x02, 0x41, 0x29, 0x9b, 0x02, 0x00, 0xe0, 0xd2, 0xfe,
		0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcb, 0xee, 0xe0, 0x50, 0x00, 0x00, 0x00, 0x00,
		0x4a, 0x18, 0x9c, 0x0a, 0x4d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	*reinterpret_cast<uint32*>(&keepAlivePacket[0x28]) = clientTime;
	*reinterpret_cast<uint32*>(&keepAlivePacket[0x30]) = moreTime;

	QueuePacket(PacketData(std::begin(keepAlivePacket), std::end(keepAlivePacket)));
}

void CGameServerPlayer::ProcessSetPlayerPosition(const PacketData& subPacket)
{
	//Some keep alive thing?
	uint32 clientTime = *reinterpret_cast<const uint32*>(&subPacket[0x18]);
	float posX = *reinterpret_cast<const float*>(&subPacket[0x28]);
	float posY = *reinterpret_cast<const float*>(&subPacket[0x2C]);
	float posZ = *reinterpret_cast<const float*>(&subPacket[0x30]);

//	printf("%s: Client Id (%d): Keeping Alive. Time: 0x%0.8X, Pos: (X: %f, Y: %f, Z: %f).\r\n",
//		LOGNAME, clientId, clientTime, posX, posY, posZ);
}

void CGameServerPlayer::ProcessScriptCommand(const PacketData& subPacket)
{
	uint32 clientTime = *reinterpret_cast<const uint32*>(&subPacket[0x18]);
	uint32 commandId = *reinterpret_cast<const uint32*>(&subPacket[0x20]);
	const char* commandName = reinterpret_cast<const char*>(subPacket.data()) + 0x31;

	printf("%s: %s Id = 0x%0.8X.\r\n", LOGNAME, commandName, commandId);

	if(!strcmp(commandName, "commandRequest"))
	{
		//commandRequest (emote, changing equipment, ...)

		uint8 emoteId = subPacket[0x55];

		printf("%s: Executing Emote 0x%0.2X\r\n", LOGNAME, emoteId);

		uint8 commandRequestPacket[0x40] =
		{
			0x01, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 0x52, 0xE2, 0xA4, 0xEE, 0x3B, 0x01, 0x00, 0x00,
			0x30, 0x00, 0x03, 0x00, 0x41, 0x29, 0x9b, 0x02, 0x41, 0x29, 0x9b, 0x02, 0x00, 0xe0, 0xd2, 0xfe,
			0x14, 0x00, 0xe1, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xee, 0xe0, 0x50, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xb0, 0x00, 0x05, 0x41, 0x29, 0x9b, 0x02, 0x6e, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		};

		//In: 0x6F, Out: (0x0500B000, 0x526E) -> Dance
		//In: 0x??, Out: (0x5000C000, 0x????) -> Angry Pointing
		//In: 0x??, Out: (0x5000D000, 0x????) -> Snooze
		//In: 0x??, Out: (0x5000E000, 0x????) -> Frustrated
		//In: 0x??, Out: (0x5000F000, 0x????) -> Military Sign
		//In: 0x??, Out: (0x50011000, 0x????) -> Shrug
		//In: 0x??, Out: (0x50012000, 0x????) -> Success Baby
		//In: 0x77, Out: (0x05013000, 0x52BE) -> Kneel
		//In: 0x??, Out: (0x50014000, 0x????) -> Chuckle
		//In: 0x??, Out: (0x50015000, 0x????) -> Laugh
		//In: 0x??, Out: (0x50016000, 0x????) -> Look
		//In: 0x??, Out: (0x50018000, 0x????) -> No
		//In: 0x??, Out: (0x50019000, 0x????) -> Never
					
		uint32 animationId = 0x0500B000;
		uint32 descriptionId = 0x526E;

		//Wrong emotes
		//gcsalute		-> grovel
		//grovel		-> serpent salute
		//blowkiss		-> disappointed
		//pray			-> firedance
		//airquote		-> pray
		//pose			-> blowkiss
		//happy			-> maelstorm salute
		//disappointed	-> pose

		if(emoteId >= 0x64 && emoteId < 0xA0)
		{
			animationId = 0x05000000 + ((emoteId - 0x64) << 12);
		}
/*
		switch(emoteId)
		{
		case 0x6A:		//Cheer
			animationId = 0x05006000;
			break;
		case 0x6F:		//Dance
			animationId = 0x0500B000;
			break;
		case 0x71:		//Doze
			animationId = 0x0500D000;
			break;
		case 0x75:		//Huh
			animationId = 0x05011000;
			break;
		case 0x78:		//Chuckle
			animationId = 0x05014000;
			break;
		case 0x79:		//Laugh
			animationId = 0x05015000;
			break;
		}
*/

		*reinterpret_cast<uint32*>(&commandRequestPacket[0x28]) = clientTime;
		*reinterpret_cast<uint32*>(&commandRequestPacket[0x30]) = animationId;
		*reinterpret_cast<uint32*>(&commandRequestPacket[0x38]) = descriptionId;

//		printf("Anim Id = 0x%0.8X, Desc Id = 0x%0.8X\r\n", animationId, descriptionId);
//		animationId += 0x1000;
//		descriptionId += 1;

		QueuePacket(PacketData(std::begin(commandRequestPacket), std::end(commandRequestPacket)));
	}
	else if(!strcmp(commandName, "talkDefault"))
	{
		static const uint8 commandRequestPacket[] =
		{
			0x01, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x01, 0x00, 0x52, 0xE2, 0xA4, 0xEE, 0x3B, 0x01, 0x00, 0x00,
			0xb0, 0x00, 0x03, 0x00, 0x41, 0x29, 0x9b, 0x02, 0x41, 0x29, 0x9b, 0x02, 0x00, 0xe0, 0xd2, 0xfe,
			0x14, 0x00, 0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0xe9, 0xe0, 0x50, 0x00, 0x00, 0x00, 0x00,
			0x41, 0x29, 0x9b, 0x02, 0x07, 0x00, 0xa0, 0x47, 0x01, 0x74, 0x61, 0x6c, 0x6b, 0x44, 0x65, 0x66,
			0x61, 0x75, 0x6c, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74,
			0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x02, 0x9b, 0x29, 0x41, 0x06, 0xa0,
			0xf1, 0xaf, 0xcd, 0x02, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x54, 0x61, 0x6c, 0x6b, 0x57,
			0x69, 0x74, 0x68, 0x49, 0x6e, 0x6e, 0x5f, 0x45, 0x78, 0x69, 0x74, 0x44, 0x6f, 0x6f, 0x72, 0x00,
			0x05, 0x05, 0x05, 0x05, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0xe8, 0x4e, 0x40, 0x00, 0x00, 0x00,
		};

		QueuePacket(PacketData(std::begin(commandRequestPacket), std::end(commandRequestPacket)));
	}
	else
	{
		//Anything else will probably crash, so just bail
		m_disconnect = true;
	}
}

void CGameServerPlayer::ProcessScriptResult(const PacketData& subPacket)
{
	if(!m_alreadyMovedOutOfRoom)
	{
		printf("%s: Command 0x12E: Moving out of room\r\n", LOGNAME);

		QueuePacket(PacketData(std::begin(g_client0_moor1), std::end(g_client0_moor1)));
		QueuePacket(PacketData(std::begin(g_client0_moor2), std::end(g_client0_moor2)));
		QueuePacket(PacketData(std::begin(g_client0_moor3), std::end(g_client0_moor3)));
		QueuePacket(PacketData(std::begin(g_client0_moor4), std::end(g_client0_moor4)));
		QueuePacket(PacketData(std::begin(g_client0_moor5), std::end(g_client0_moor5)));
		QueuePacket(PacketData(std::begin(g_client0_moor6), std::end(g_client0_moor6)));
		QueuePacket(PacketData(std::begin(g_client0_moor7), std::end(g_client0_moor7)));
		QueuePacket(PacketData(std::begin(g_client0_moor8), std::end(g_client0_moor8)));
		QueuePacket(PacketData(std::begin(g_client0_moor9), std::end(g_client0_moor9)));
		QueuePacket(PacketData(std::begin(g_client0_moor10), std::end(g_client0_moor10)));
		QueuePacket(PacketData(std::begin(g_client0_moor11), std::end(g_client0_moor11)));
		QueuePacket(PacketData(std::begin(g_client0_moor12), std::end(g_client0_moor12)));
		QueuePacket(PacketData(std::begin(g_client0_moor13), std::end(g_client0_moor13)));
		QueuePacket(PacketData(std::begin(g_client0_moor14), std::end(g_client0_moor14)));
		QueuePacket(PacketData(std::begin(g_client0_moor15), std::end(g_client0_moor15)));
		QueuePacket(PacketData(std::begin(g_client0_moor16), std::end(g_client0_moor16)));
		QueuePacket(PacketData(std::begin(g_client0_moor17), std::end(g_client0_moor17)));
		QueuePacket(PacketData(std::begin(g_client0_moor18), std::end(g_client0_moor18)));
		QueuePacket(PacketData(std::begin(g_client0_moor19), std::end(g_client0_moor19)));
		QueuePacket(PacketData(std::begin(g_client0_moor20), std::end(g_client0_moor20)));
		QueuePacket(PacketData(std::begin(g_client0_moor21), std::end(g_client0_moor21)));
		QueuePacket(PacketData(std::begin(g_client0_moor22), std::end(g_client0_moor22)));
		QueuePacket(PacketData(std::begin(g_client0_moor23), std::end(g_client0_moor23)));
		QueuePacket(PacketData(std::begin(g_client0_moor24), std::end(g_client0_moor24)));
		QueuePacket(PacketData(std::begin(g_client0_moor25), std::end(g_client0_moor25)));
		QueuePacket(PacketData(std::begin(g_client0_moor26), std::end(g_client0_moor26)));
		QueuePacket(PacketData(std::begin(g_client0_moor27), std::end(g_client0_moor27)));
		QueuePacket(PacketData(std::begin(g_client0_moor28), std::end(g_client0_moor28)));
		QueuePacket(PacketData(std::begin(g_client0_moor29), std::end(g_client0_moor29)));
		QueuePacket(PacketData(std::begin(g_client0_moor30), std::end(g_client0_moor30)));
		QueuePacket(PacketData(std::begin(g_client0_moor31), std::end(g_client0_moor31)));
		QueuePacket(PacketData(std::begin(g_client0_moor32), std::end(g_client0_moor32)));
		QueuePacket(PacketData(std::begin(g_client0_moor33), std::end(g_client0_moor33)));
		QueuePacket(PacketData(std::begin(g_client0_moor34), std::end(g_client0_moor34)));
		QueuePacket(PacketData(std::begin(g_client0_moor35), std::end(g_client0_moor35)));
		QueuePacket(PacketData(std::begin(g_client0_moor36), std::end(g_client0_moor36)));
		QueuePacket(PacketData(std::begin(g_client0_moor37), std::end(g_client0_moor37)));
		QueuePacket(PacketData(std::begin(g_client0_moor38), std::end(g_client0_moor38)));
		QueuePacket(PacketData(std::begin(g_client0_moor39), std::end(g_client0_moor39)));
		QueuePacket(PacketData(std::begin(g_client0_moor40), std::end(g_client0_moor40)));

		m_alreadyMovedOutOfRoom = true;
	}
}
